{"ast":null,"code":"import { InjectionToken, Injectable, ɵɵdefineInjectable, EventEmitter, Directive, Optional, Inject, ElementRef, NgZone, Renderer2, Input, Output, NgModule } from '@angular/core';\nimport Sortable from 'sortablejs';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/globals.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nconst GLOBALS = new InjectionToken('Global config for sortablejs');\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/sortablejs-binding.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nclass SortablejsBinding {\n  /**\n   * @param {?} target\n   */\n  constructor(target) {\n    this.target = target;\n  }\n  /**\n   * @param {?} index\n   * @param {?} item\n   * @return {?}\n   */\n\n\n  insert(index, item) {\n    if (this.isFormArray) {\n      this.target.insert(index, item);\n    } else {\n      this.target.splice(index, 0, item);\n    }\n  }\n  /**\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  get(index) {\n    return this.isFormArray ? this.target.at(index) : this.target[index];\n  }\n  /**\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  remove(index) {\n    /** @type {?} */\n    let item;\n\n    if (this.isFormArray) {\n      item = this.target.at(index);\n      this.target.removeAt(index);\n    } else {\n      item = this.target.splice(index, 1)[0];\n    }\n\n    return item;\n  } // we need this to identify that the target is a FormArray\n  // we don't want to have a dependency on @angular/forms just for that\n\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  get isFormArray() {\n    // just checking for random FormArray methods not available on a standard array\n    return !!this.target.at && !!this.target.insert && !!this.target.reset;\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  SortablejsBinding.prototype.target;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/sortablejs-bindings.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass SortablejsBindings {\n  /**\n   * @param {?} bindingTargets\n   */\n  constructor(bindingTargets) {\n    this.bindings = bindingTargets.map(\n    /**\n    * @param {?} target\n    * @return {?}\n    */\n    target => new SortablejsBinding(target));\n  }\n  /**\n   * @param {?} index\n   * @param {?} items\n   * @return {?}\n   */\n\n\n  injectIntoEvery(index, items) {\n    this.bindings.forEach(\n    /**\n    * @param {?} b\n    * @param {?} i\n    * @return {?}\n    */\n    (b, i) => b.insert(index, items[i]));\n  }\n  /**\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  getFromEvery(index) {\n    return this.bindings.map(\n    /**\n    * @param {?} b\n    * @return {?}\n    */\n    b => b.get(index));\n  }\n  /**\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  extractFromEvery(index) {\n    return this.bindings.map(\n    /**\n    * @param {?} b\n    * @return {?}\n    */\n    b => b.remove(index));\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get provided() {\n    return !!this.bindings.length;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  SortablejsBindings.prototype.bindings;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/sortablejs.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet SortablejsService = /*#__PURE__*/(() => {\n  class SortablejsService {}\n\n  SortablejsService.ɵfac = function SortablejsService_Factory(t) {\n    return new (t || SortablejsService)();\n  };\n  /** @nocollapse */\n\n\n  SortablejsService.ɵprov = ɵɵdefineInjectable({\n    factory: function SortablejsService_Factory() {\n      return new SortablejsService();\n    },\n    token: SortablejsService,\n    providedIn: \"root\"\n  });\n  return SortablejsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  SortablejsService.prototype.transfer;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/sortablejs.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst getIndexesFromEvent =\n/**\n* @param {?} event\n* @return {?}\n*/\nevent => {\n  if (event.hasOwnProperty('newDraggableIndex') && event.hasOwnProperty('oldDraggableIndex')) {\n    return {\n      new: event.newDraggableIndex,\n      old: event.oldDraggableIndex\n    };\n  } else {\n    return {\n      new: event.newIndex,\n      old: event.oldIndex\n    };\n  }\n};\n\nconst ɵ0 = getIndexesFromEvent;\nlet SortablejsDirective = /*#__PURE__*/(() => {\n  class SortablejsDirective {\n    /**\n     * @param {?} globalConfig\n     * @param {?} service\n     * @param {?} element\n     * @param {?} zone\n     * @param {?} renderer\n     */\n    constructor(globalConfig, service, element, zone, renderer) {\n      this.globalConfig = globalConfig;\n      this.service = service;\n      this.element = element;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.sortablejsInit = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (Sortable && Sortable.create) {\n        // Sortable does not exist in angular universal (SSR)\n        this.create();\n      }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      /** @type {?} */\n      const optionsChange = changes.sortablejsOptions;\n\n      if (optionsChange && !optionsChange.isFirstChange()) {\n        /** @type {?} */\n        const previousOptions = optionsChange.previousValue;\n        /** @type {?} */\n\n        const currentOptions = optionsChange.currentValue;\n        Object.keys(currentOptions).forEach(\n        /**\n        * @param {?} optionName\n        * @return {?}\n        */\n        optionName => {\n          if (currentOptions[optionName] !== previousOptions[optionName]) {\n            // use low-level option setter\n            this.sortableInstance.option(optionName, this.options[optionName]);\n          }\n        });\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.sortableInstance) {\n        this.sortableInstance.destroy();\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    create() {\n      /** @type {?} */\n      const container = this.sortablejsContainer ? this.element.nativeElement.querySelector(this.sortablejsContainer) : this.element.nativeElement;\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.sortableInstance = Sortable.create(container, this.options);\n        this.sortablejsInit.emit(this.sortableInstance);\n      }, 0);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    getBindings() {\n      if (!this.sortablejs) {\n        return new SortablejsBindings([]);\n      } else if (this.sortablejs instanceof SortablejsBindings) {\n        return this.sortablejs;\n      } else {\n        return new SortablejsBindings([this.sortablejs]);\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get options() {\n      return Object.assign(Object.assign({}, this.optionsWithoutEvents), this.overridenOptions);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get optionsWithoutEvents() {\n      return Object.assign(Object.assign({}, this.globalConfig || {}), this.sortablejsOptions || {});\n    }\n    /**\n     * @private\n     * @param {?} eventName\n     * @param {...?} params\n     * @return {?}\n     */\n\n\n    proxyEvent(eventName, ...params) {\n      this.zone.run(\n      /**\n      * @return {?}\n      */\n      () => {\n        if (this.optionsWithoutEvents && this.optionsWithoutEvents[eventName]) {\n          this.optionsWithoutEvents[eventName](...params);\n        }\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get isCloning() {\n      return this.sortableInstance.options.group.checkPull(this.sortableInstance, this.sortableInstance) === 'clone';\n    }\n    /**\n     * @private\n     * @template T\n     * @param {?} item\n     * @return {?}\n     */\n\n\n    clone(item) {\n      // by default pass the item through, no cloning performed\n      return (this.sortablejsCloneFunction || (\n      /**\n      * @param {?} subitem\n      * @return {?}\n      */\n      subitem => subitem))(item);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    get overridenOptions() {\n      // always intercept standard events but act only in case items are set (bindingEnabled)\n      // allows to forget about tracking this.items changes\n      return {\n        onAdd:\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          this.service.transfer =\n          /**\n          * @param {?} items\n          * @return {?}\n          */\n          items => {\n            this.getBindings().injectIntoEvery(event.newIndex, items);\n            this.proxyEvent('onAdd', event);\n          };\n\n          this.proxyEvent('onAddOriginal', event);\n        },\n        onRemove:\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          /** @type {?} */\n          const bindings = this.getBindings();\n\n          if (bindings.provided) {\n            if (this.isCloning) {\n              this.service.transfer(bindings.getFromEvery(event.oldIndex).map(\n              /**\n              * @param {?} item\n              * @return {?}\n              */\n              item => this.clone(item))); // great thanks to https://github.com/tauu\n              // event.item is the original item from the source list which is moved to the target list\n              // event.clone is a clone of the original item and will be added to source list\n              // If bindings are provided, adding the item dom element to the target list causes artifacts\n              // as it interferes with the rendering performed by the angular template.\n              // Therefore we remove it immediately and also move the original item back to the source list.\n              // (event handler may be attached to the original item and not its clone, therefore keeping\n              // the original dom node, circumvents side effects )\n\n              this.renderer.removeChild(event.item.parentNode, event.item);\n              this.renderer.insertBefore(event.clone.parentNode, event.item, event.clone);\n              this.renderer.removeChild(event.clone.parentNode, event.clone);\n            } else {\n              this.service.transfer(bindings.extractFromEvery(event.oldIndex));\n            }\n\n            this.service.transfer = null;\n          }\n\n          this.proxyEvent('onRemove', event);\n        },\n        onUpdate:\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          /** @type {?} */\n          const bindings = this.getBindings();\n          /** @type {?} */\n\n          const indexes = getIndexesFromEvent(event);\n          bindings.injectIntoEvery(indexes.new, bindings.extractFromEvery(indexes.old));\n          this.proxyEvent('onUpdate', event);\n        }\n      };\n    }\n\n  }\n\n  SortablejsDirective.ɵfac = function SortablejsDirective_Factory(t) {\n    return new (t || SortablejsDirective)(ɵngcc0.ɵɵdirectiveInject(GLOBALS, 8), ɵngcc0.ɵɵdirectiveInject(SortablejsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  SortablejsDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SortablejsDirective,\n    selectors: [[\"\", \"sortablejs\", \"\"]],\n    inputs: {\n      sortablejs: \"sortablejs\",\n      sortablejsContainer: \"sortablejsContainer\",\n      sortablejsOptions: \"sortablejsOptions\",\n      sortablejsCloneFunction: \"sortablejsCloneFunction\"\n    },\n    outputs: {\n      sortablejsInit: \"sortablejsInit\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return SortablejsDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  SortablejsDirective.prototype.sortablejs;\n  /** @type {?} */\n\n  SortablejsDirective.prototype.sortablejsContainer;\n  /** @type {?} */\n\n  SortablejsDirective.prototype.sortablejsOptions;\n  /** @type {?} */\n\n  SortablejsDirective.prototype.sortablejsCloneFunction;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.sortableInstance;\n  /** @type {?} */\n\n  SortablejsDirective.prototype.sortablejsInit;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.globalConfig;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.service;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  SortablejsDirective.prototype.renderer;\n}\n/**\n * @record\n */\n\n\nfunction SortableEvent() {}\n\nif (false) {\n  /** @type {?} */\n  SortableEvent.prototype.oldIndex;\n  /** @type {?} */\n\n  SortableEvent.prototype.newIndex;\n  /** @type {?|undefined} */\n\n  SortableEvent.prototype.oldDraggableIndex;\n  /** @type {?|undefined} */\n\n  SortableEvent.prototype.newDraggableIndex;\n  /** @type {?} */\n\n  SortableEvent.prototype.item;\n  /** @type {?} */\n\n  SortableEvent.prototype.clone;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/sortablejs.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet SortablejsModule = /*#__PURE__*/(() => {\n  class SortablejsModule {\n    /**\n     * @param {?} globalOptions\n     * @return {?}\n     */\n    static forRoot(globalOptions) {\n      return {\n        ngModule: SortablejsModule,\n        providers: [{\n          provide: GLOBALS,\n          useValue: globalOptions\n        }]\n      };\n    }\n\n  }\n\n  SortablejsModule.ɵfac = function SortablejsModule_Factory(t) {\n    return new (t || SortablejsModule)();\n  };\n\n  SortablejsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: SortablejsModule\n  });\n  SortablejsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return SortablejsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SortablejsModule, {\n    declarations: [SortablejsDirective],\n    exports: [SortablejsDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngx-sortablejs.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { SortablejsDirective, SortablejsModule, GLOBALS as ɵa, SortablejsService as ɵb }; //# sourceMappingURL=ngx-sortablejs.js.map","map":null,"metadata":{},"sourceType":"module"}